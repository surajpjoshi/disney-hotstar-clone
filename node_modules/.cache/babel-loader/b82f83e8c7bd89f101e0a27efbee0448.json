{"ast":null,"code":"import React, { useState, useRef, useEffect, useMemo } from 'react';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n}; // CSS styles to make some contents in the player expand to fill the container\n\n\nvar expandToFillContainerStyle = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0\n}; // Styles to apply to the paused overlay wrapper for each sizing mode\n\nvar pausedOverlayWrapperSizingStyles = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative'\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null\n}; // Styles to apply to the video element for each sizing mode\n\nvar videoSizingStyles = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%'\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null\n};\n/**\r\n * @function  formatVideoSrc\r\n *\r\n * Takes a videoSrc value and formats it as an array of VideoSource objects which can be used to render\r\n * <source> elements for the video\r\n *\r\n * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.\r\n *\r\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\r\n */\n\nfunction formatVideoSrc(videoSrc) {\n  var formattedVideoSources = [];\n\n  if (videoSrc == null) {\n    // A videoSrc value is required in order to make the video player work\n    console.error(\"Error: 'videoSrc' prop is required for HoverVideoPlayer component\");\n  } else {\n    // Make sure we can treat the videoSrc value as an array\n    var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc]; // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n\n    for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {\n      var source = rawVideoSources[i];\n\n      if (typeof source === 'string') {\n        // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n        formattedVideoSources.push({\n          src: source\n        });\n      } else if (source && source.src) {\n        // If the source is an object with an src, just add it to the array\n        formattedVideoSources.push({\n          src: source.src,\n          type: source.type\n        });\n      } else {\n        // Log an error if one of the videoSrc values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\", source);\n      }\n    }\n  }\n\n  return formattedVideoSources;\n}\n/**\r\n * @function formatVideoCaptions\r\n *\r\n * Takes a videoCaptions value and formats it as an array of VideoCaptionsTrack objects which can be used to render\r\n * <track> elements for the video\r\n *\r\n * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.\r\n *\r\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\r\n */\n\n\nfunction formatVideoCaptions(videoCaptions) {\n  var formattedVideoCaptions = []; // If captions were provided, format them for use for the video\n\n  if (videoCaptions != null) {\n    // Make sure we can treat the videoCaptions value as an array\n    var rawVideoCaptions = Array.isArray(videoCaptions) ? videoCaptions : [videoCaptions]; // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n    // objects that can be used to render caption tracks for the video\n\n    for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {\n      var captions = rawVideoCaptions[i];\n\n      if (captions && captions.src) {\n        formattedVideoCaptions.push({\n          src: captions.src,\n          srcLang: captions.srcLang,\n          label: captions.label,\n          default: Boolean(captions.default)\n        });\n      } else {\n        // Log an error if one of the videoCaptions values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\", captions);\n      }\n    }\n  }\n\n  return formattedVideoCaptions;\n} // Enumerates states that the hover player's overlay can be in\n\n\nvar OverlayState;\n\n(function (OverlayState) {\n  // Only the paused overlay is visible, if provided\n  OverlayState[\"paused\"] = \"paused\"; // Both the paused and loading overlays are visible, if provided\n\n  OverlayState[\"loading\"] = \"loading\"; // No overlays are visible\n\n  OverlayState[\"playing\"] = \"playing\";\n})(OverlayState || (OverlayState = {}));\n/**\r\n * @component HoverVideoPlayer\r\n * @license MIT\r\n *\r\n * @param {HoverVideoPlayerProps} props\r\n */\n\n\nvar HoverVideoPlayer = function (_a) {\n  var videoSrc = _a.videoSrc,\n      _b = _a.videoCaptions,\n      videoCaptions = _b === void 0 ? null : _b,\n      _c = _a.focused,\n      focused = _c === void 0 ? false : _c,\n      _d = _a.disableDefaultEventHandling,\n      disableDefaultEventHandling = _d === void 0 ? false : _d,\n      _e = _a.hoverTargetRef,\n      hoverTargetRef = _e === void 0 ? null : _e,\n      _f = _a.pausedOverlay,\n      pausedOverlay = _f === void 0 ? null : _f,\n      _g = _a.loadingOverlay,\n      loadingOverlay = _g === void 0 ? null : _g,\n      _h = _a.loadingStateTimeout,\n      loadingStateTimeout = _h === void 0 ? 200 : _h,\n      _j = _a.overlayTransitionDuration,\n      overlayTransitionDuration = _j === void 0 ? 400 : _j,\n      _k = _a.restartOnPaused,\n      restartOnPaused = _k === void 0 ? false : _k,\n      _l = _a.unloadVideoOnPaused,\n      unloadVideoOnPaused = _l === void 0 ? false : _l,\n      _m = _a.muted,\n      muted = _m === void 0 ? true : _m,\n      _o = _a.volume,\n      volume = _o === void 0 ? 1 : _o,\n      _p = _a.loop,\n      loop = _p === void 0 ? true : _p,\n      _q = _a.preload,\n      preload = _q === void 0 ? null : _q,\n      _r = _a.crossOrigin,\n      crossOrigin = _r === void 0 ? 'anonymous' : _r,\n      _s = _a.controls,\n      controls = _s === void 0 ? false : _s,\n      _t = _a.controlsList,\n      controlsList = _t === void 0 ? null : _t,\n      _u = _a.disableRemotePlayback,\n      disableRemotePlayback = _u === void 0 ? true : _u,\n      _v = _a.disablePictureInPicture,\n      disablePictureInPicture = _v === void 0 ? true : _v,\n      _w = _a.className,\n      className = _w === void 0 ? null : _w,\n      _x = _a.style,\n      style = _x === void 0 ? null : _x,\n      _y = _a.pausedOverlayWrapperClassName,\n      pausedOverlayWrapperClassName = _y === void 0 ? null : _y,\n      _z = _a.pausedOverlayWrapperStyle,\n      pausedOverlayWrapperStyle = _z === void 0 ? null : _z,\n      _0 = _a.loadingOverlayWrapperClassName,\n      loadingOverlayWrapperClassName = _0 === void 0 ? null : _0,\n      _1 = _a.loadingOverlayWrapperStyle,\n      loadingOverlayWrapperStyle = _1 === void 0 ? null : _1,\n      _2 = _a.videoId,\n      videoId = _2 === void 0 ? null : _2,\n      _3 = _a.videoClassName,\n      videoClassName = _3 === void 0 ? null : _3,\n      _4 = _a.videoStyle,\n      videoStyle = _4 === void 0 ? null : _4,\n      _5 = _a.sizingMode,\n      sizingMode = _5 === void 0 ? 'video' : _5; // Keep track of whether the user is hovering over the video and it should therefore be playing or not\n\n  var _6 = useState(false),\n      isHoveringOverVideo = _6[0],\n      setIsHoveringOverVideo = _6[1]; // Keep track of how the paused and loading overlays should be displayed\n\n\n  var _7 = useState(OverlayState.paused),\n      overlayState = _7[0],\n      setOverlayState = _7[1];\n\n  var _8 = useState(true),\n      isVideoPaused = _8[0],\n      setIsVideoPaused = _8[1]; // Keep a ref for all state variables related to the video's state\n  // which need to be managed asynchronously as it attempts to play/pause\n\n\n  var mutableVideoState = useRef(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      // Whether there is a play promise in progress which we should avoid interrupting\n      // with calls to video.play() or video.load()\n      isPlayAttemptInProgress: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: 0\n    };\n  } // Element refs\n\n\n  var containerRef = useRef(null);\n  var videoRef = useRef(null);\n  var hasPausedOverlay = Boolean(pausedOverlay);\n  var hasLoadingOverlay = Boolean(loadingOverlay); // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled\n\n  var shouldPlayVideo = isHoveringOverVideo || focused;\n  /* ~~~~ EFFECTS ~~~~ */\n  // Effect starts and stops the video depending on the current value for `shouldPlayVideo`\n\n  useEffect(function () {\n    var videoElement = videoRef.current; // If shouldPlayVideo is true, attempt to start playing the video\n\n    if (shouldPlayVideo) {\n      // Use heuristics to check if the video is already playing.\n      if ( // A video is playing if...\n      // The video isn't paused\n      !videoElement.paused && // The video hasn't ended\n      !videoElement.ended && // The video has loaded enough data that it can play\n      // (readyState 3 is HAVE_FUTURE_DATA, meaning the video has loaded enough data that it can play)\n      videoElement.readyState >= 3) {\n        // If the video is already playing, ensure the overlays are hidden to reflect that!\n        setOverlayState(OverlayState.playing);\n      } else {\n        // If the video is not currently playing, proceed to kick off a loading timeout if needed and attempt to play the video\n        // if there isn't already one in progress\n        if (hasLoadingOverlay) {\n          // If we have a loading overlay, set a timeout to start showing it if the video doesn't start playing\n          // before the loading state timeout has elapsed\n          mutableVideoState.current.loadingStateTimeout = setTimeout(function () {\n            // If this timeout wasn't cancelled, we're still trying to play the video\n            // and it's still loading, so fade in the loading overlay\n            setOverlayState(OverlayState.loading);\n          }, loadingStateTimeout);\n        } // If videoElement.paused is false that means a play attempt is already in progress so there's no need to actually\n        // start attempting to play again. This can happen if the video is taking a long time to load and still hasn't\n        // finished since the user has hovered off of the player and then back on again.\n\n\n        if (videoElement.paused) {\n          // Ensure we're at the correct time to start playing from\n          videoElement.currentTime = mutableVideoState.current.videoTimeToRestore; // Start attempting to play\n\n          videoElement.play();\n        }\n      }\n    } // Otherwise if shouldPlayVideo is false, go through the process necessary to pause the video\n    else {\n        // Start fading the paused overlay back in\n        setOverlayState(OverlayState.paused); // Only proceed to pause the video if it's not already paused\n\n        if (!videoElement.paused) {\n          var pauseVideo = function () {\n            // If there isn't a play attempt in progress and the video can therefore\n            //  safely be paused right away, do it!\n            // Otherwise, we'll have to wait for the logic in the video's `onPlaying` event\n            // to immediately pause the video as soon as it starts playing, or else we will end up\n            // getting an error for interrupting the play promise\n            if (!mutableVideoState.current.isPlayAttemptInProgress) {\n              videoElement.pause();\n            }\n          };\n\n          if (hasPausedOverlay) {\n            // If we have a paused overlay, set a timeout with a duration of the overlay's fade\n            // transition since we want to keep the video playing until the overlay has fully\n            // faded in and hidden it.\n            mutableVideoState.current.pauseTimeout = setTimeout(pauseVideo, overlayTransitionDuration);\n          } else {\n            // If we don't have a paused overlay, pause right away!\n            pauseVideo();\n          }\n        }\n      }\n\n    return function () {\n      // On cleanup, clear any outstanding timeouts since our playback state is changing\n      // or the component is unmounting\n      clearTimeout(mutableVideoState.current.pauseTimeout);\n      clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    };\n  }, // Only run the effect when shouldPlayVideo changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [shouldPlayVideo]); // If the video's sources should be unloaded when it's paused, the video is paused, AND we're not currently\n  // trying to play, we can unload the video's sources\n\n  var isVideoUnloaded = unloadVideoOnPaused && isVideoPaused && !shouldPlayVideo; // Effect ensures the video element fully unloads after its <source> tags were removed\n\n  useEffect(function () {\n    if (isVideoUnloaded) {\n      // Since the video's sources have changed, perform a manual load to update\n      // or unload the video's current source\n      videoRef.current.load();\n    }\n  }, [isVideoUnloaded]); // Effect adds hover event listeners to the appropriate hover target element so it will start and stop as the user interacts with it\n\n  useEffect(function () {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined; // If a ref to a custom hover target was provided, we'll use that as our target element,\n    // but otherwise just default to our container element\n\n    var hoverTargetElement = (hoverTargetRef || containerRef).current; // Add the event listeners\n\n    var onHoverStart = function () {\n      return setIsHoveringOverVideo(true);\n    };\n\n    var onHoverEnd = function () {\n      return setIsHoveringOverVideo(false);\n    }; // Mouse events\n\n\n    hoverTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverTargetElement.addEventListener('mouseleave', onHoverEnd); // Focus/blur\n\n    hoverTargetElement.addEventListener('focus', onHoverStart);\n    hoverTargetElement.addEventListener('blur', onHoverEnd); // Touch events\n\n    hoverTargetElement.addEventListener('touchstart', onHoverStart); // Event listener pauses the video when the user touches somewhere outside of the player\n\n    var onWindowTouchStart = function (event) {\n      if (!hoverTargetElement.contains(event.target)) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener('touchstart', onWindowTouchStart); // Return a cleanup function that removes all event listeners\n\n    return function () {\n      hoverTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverTargetElement.removeEventListener('focus', onHoverStart);\n      hoverTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetRef]); // Effect sets attributes on the video which can't be done via props\n\n  useEffect(function () {\n    var videoElement = videoRef.current; // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n\n    videoElement.muted = muted; // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n\n    videoElement.volume = volume; // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n    // via the video element's props, so make sure we manually set them in an effect\n\n    videoElement.disableRemotePlayback = disableRemotePlayback;\n    videoElement.disablePictureInPicture = disablePictureInPicture;\n  }, [disablePictureInPicture, disableRemotePlayback, muted, volume]);\n  /* ~~~~ END EFFECTS ~~~~ */\n\n  var isPausedOverlayVisible = overlayState !== OverlayState.playing;\n  var isLoadingOverlayVisibile = overlayState === OverlayState.loading; // Parse the sources and captions into formatted arrays that we can use to\n  // render <source> and <track> elements for the video\n\n  var formattedVideoSources = useMemo(function () {\n    return formatVideoSrc(videoSrc);\n  }, [videoSrc]);\n  var formattedVideoCaptions = useMemo(function () {\n    return formatVideoCaptions(videoCaptions);\n  }, [videoCaptions]);\n  return React.createElement(\"div\", {\n    \"data-testid\": \"hover-video-player-container\",\n    ref: containerRef,\n    className: className,\n    style: __assign({\n      position: 'relative'\n    }, style)\n  }, hasPausedOverlay && React.createElement(\"div\", {\n    style: __assign(__assign(__assign({}, pausedOverlayWrapperSizingStyles[sizingMode]), {\n      zIndex: 1,\n      opacity: isPausedOverlayVisible ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\",\n      // Disable pointer events on the paused overlay when it's hidden\n      pointerEvents: isPausedOverlayVisible ? 'auto' : 'none'\n    }), pausedOverlayWrapperStyle),\n    className: pausedOverlayWrapperClassName,\n    \"data-testid\": \"paused-overlay-wrapper\"\n  }, pausedOverlay), hasLoadingOverlay && React.createElement(\"div\", {\n    style: __assign(__assign(__assign({}, expandToFillContainerStyle), {\n      zIndex: 2,\n      opacity: isLoadingOverlayVisibile ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\",\n      // Disable pointer events on the loading overlay when it's hidden\n      pointerEvents: isLoadingOverlayVisibile ? 'auto' : 'none'\n    }), loadingOverlayWrapperStyle),\n    className: loadingOverlayWrapperClassName,\n    \"data-testid\": \"loading-overlay-wrapper\"\n  }, loadingOverlay), React.createElement(\"video\", {\n    loop: loop,\n    playsInline: true,\n    preload: preload,\n    crossOrigin: crossOrigin,\n    ref: videoRef,\n    style: __assign(__assign(__assign({}, videoSizingStyles[sizingMode]), {\n      objectFit: 'cover'\n    }), videoStyle),\n    controls: controls,\n    controlsList: controlsList,\n    className: videoClassName,\n    id: videoId,\n    onError: function () {\n      // Event fired when an error occurred on the video element, usually because something went wrong\n      // when attempting to load its source\n      console.error(\"HoverVideoPlayer encountered an error for src \\\"\" + videoRef.current.currentSrc + \"\\\".\");\n    },\n    onPlay: function () {\n      // Mark that we now have a play attempt in progress which shouldn't be interrupted\n      mutableVideoState.current.isPlayAttemptInProgress = true; // The video is no longer paused\n\n      setIsVideoPaused(false);\n    },\n    onPlaying: function () {\n      // Cancel any state timeouts that may be pending\n      clearTimeout(mutableVideoState.current.pauseTimeout);\n      clearTimeout(mutableVideoState.current.loadingStateTimeout); // The play attempt is now complete\n\n      mutableVideoState.current.isPlayAttemptInProgress = false;\n\n      if (shouldPlayVideo) {\n        // Hide the overlays to reveal the video now that it's playing\n        setOverlayState(OverlayState.playing);\n      } else {\n        // If the play attempt just succeeded but we no longer want to play the video,\n        // pause it immediately!\n        videoRef.current.pause();\n      }\n    },\n    onPause: function () {\n      // Cancel any state timeouts that may be pending\n      clearTimeout(mutableVideoState.current.pauseTimeout);\n      clearTimeout(mutableVideoState.current.loadingStateTimeout);\n\n      if (restartOnPaused) {\n        // If we should restart the video when paused, reset its time to the beginning\n        videoRef.current.currentTime = 0;\n      } // Hang onto the time that the video is currently at so we can\n      // restore it when we try to play again\n      // This is mainly helpful because the unloadVideoOnPaused prop will cause\n      // the video's currentTime to be cleared every time its sources are unloaded\n      // after pausing\n\n\n      mutableVideoState.current.videoTimeToRestore = videoRef.current.currentTime; // Update that the video is now paused\n\n      setIsVideoPaused(true);\n    },\n    \"data-testid\": \"video-element\"\n  }, !isVideoUnloaded && // Only render sources for the video if it is not unloaded\n  formattedVideoSources.map(function (_a) {\n    var src = _a.src,\n        type = _a.type;\n    return React.createElement(\"source\", {\n      key: src,\n      src: src,\n      type: type\n    });\n  }), formattedVideoCaptions.map(function (_a) {\n    var src = _a.src,\n        srcLang = _a.srcLang,\n        label = _a.label,\n        isDefault = _a.default;\n    return React.createElement(\"track\", {\n      key: src,\n      kind: \"captions\",\n      src: src,\n      srcLang: srcLang,\n      label: label,\n      default: isDefault\n    });\n  })));\n};\n\nexport default HoverVideoPlayer;","map":{"version":3,"sources":["../node_modules/tslib/tslib.es6.js","../src/HoverVideoPlayer.styles.ts","../src/HoverVideoPlayer.tsx"],"names":[],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import React from 'react';\n\n// CSS styles to make some contents in the player expand to fill the container\nexport const expandToFillContainerStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n};\n\ninterface SizingModeStyle {\n  video: React.CSSProperties;\n  overlay: React.CSSProperties;\n  container: React.CSSProperties;\n  manual: React.CSSProperties;\n}\n\n// Styles to apply to the paused overlay wrapper for each sizing mode\nexport const pausedOverlayWrapperSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative',\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null,\n};\n\n// Styles to apply to the video element for each sizing mode\nexport const videoSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%',\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null,\n};\n","import React, { useState, useEffect, useRef, useMemo } from 'react';\n\nimport {\n  expandToFillContainerStyle,\n  pausedOverlayWrapperSizingStyles,\n  videoSizingStyles,\n} from './HoverVideoPlayer.styles';\nimport {\n  HoverVideoPlayerProps,\n  VideoSource,\n  VideoSrcProp,\n  VideoCaptionsTrack,\n  VideoCaptionsProp,\n} from './HoverVideoPlayer.types';\n\n/**\n * @function  formatVideoSrc\n *\n * Takes a videoSrc value and formats it as an array of VideoSource objects which can be used to render\n * <source> elements for the video\n *\n * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.\n *\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\n */\nfunction formatVideoSrc(videoSrc: VideoSrcProp): VideoSource[] {\n  const formattedVideoSources = [];\n\n  if (videoSrc == null) {\n    // A videoSrc value is required in order to make the video player work\n    console.error(\n      \"Error: 'videoSrc' prop is required for HoverVideoPlayer component\"\n    );\n  } else {\n    // Make sure we can treat the videoSrc value as an array\n    const rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];\n\n    // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n    for (\n      let i = 0, numSources = rawVideoSources.length;\n      i < numSources;\n      i += 1\n    ) {\n      const source = rawVideoSources[i];\n\n      if (typeof source === 'string') {\n        // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n        formattedVideoSources.push({ src: source });\n      } else if (source && source.src) {\n        // If the source is an object with an src, just add it to the array\n        formattedVideoSources.push({ src: source.src, type: source.type });\n      } else {\n        // Log an error if one of the videoSrc values is invalid\n        console.error(\n          \"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\",\n          source\n        );\n      }\n    }\n  }\n\n  return formattedVideoSources;\n}\n\n/**\n * @function formatVideoCaptions\n *\n * Takes a videoCaptions value and formats it as an array of VideoCaptionsTrack objects which can be used to render\n * <track> elements for the video\n *\n * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.\n *\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\n */\nfunction formatVideoCaptions(\n  videoCaptions: VideoCaptionsProp\n): VideoCaptionsTrack[] {\n  const formattedVideoCaptions = [];\n\n  // If captions were provided, format them for use for the video\n  if (videoCaptions != null) {\n    // Make sure we can treat the videoCaptions value as an array\n    const rawVideoCaptions = Array.isArray(videoCaptions)\n      ? videoCaptions\n      : [videoCaptions];\n\n    // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n    // objects that can be used to render caption tracks for the video\n    for (\n      let i = 0, numCaptions = rawVideoCaptions.length;\n      i < numCaptions;\n      i += 1\n    ) {\n      const captions = rawVideoCaptions[i];\n\n      if (captions && captions.src) {\n        formattedVideoCaptions.push({\n          src: captions.src,\n          srcLang: captions.srcLang,\n          label: captions.label,\n          default: Boolean(captions.default),\n        });\n      } else {\n        // Log an error if one of the videoCaptions values is invalid\n        console.error(\n          \"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\",\n          captions\n        );\n      }\n    }\n  }\n\n  return formattedVideoCaptions;\n}\n\n// Enumerates states that the hover player's overlay can be in\nenum OverlayState {\n  // Only the paused overlay is visible, if provided\n  paused = 'paused',\n  // Both the paused and loading overlays are visible, if provided\n  loading = 'loading',\n  // No overlays are visible\n  playing = 'playing',\n}\n\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */\nconst HoverVideoPlayer: React.FC<HoverVideoPlayerProps> = ({\n  videoSrc,\n  videoCaptions = null,\n  focused = false,\n  disableDefaultEventHandling = false,\n  hoverTargetRef = null,\n  pausedOverlay = null,\n  loadingOverlay = null,\n  loadingStateTimeout = 200,\n  overlayTransitionDuration = 400,\n  restartOnPaused = false,\n  unloadVideoOnPaused = false,\n  muted = true,\n  volume = 1,\n  loop = true,\n  preload = null,\n  crossOrigin = 'anonymous',\n  controls = false,\n  controlsList = null,\n  disableRemotePlayback = true,\n  disablePictureInPicture = true,\n  className = null,\n  style = null,\n  pausedOverlayWrapperClassName = null,\n  pausedOverlayWrapperStyle = null,\n  loadingOverlayWrapperClassName = null,\n  loadingOverlayWrapperStyle = null,\n  videoId = null,\n  videoClassName = null,\n  videoStyle = null,\n  sizingMode = 'video',\n}: HoverVideoPlayerProps) => {\n  // Keep track of whether the user is hovering over the video and it should therefore be playing or not\n  const [isHoveringOverVideo, setIsHoveringOverVideo] = useState(false);\n  // Keep track of how the paused and loading overlays should be displayed\n  const [overlayState, setOverlayState] = useState(OverlayState.paused);\n  const [isVideoPaused, setIsVideoPaused] = useState(true);\n\n  // Keep a ref for all state variables related to the video's state\n  // which need to be managed asynchronously as it attempts to play/pause\n  const mutableVideoState = useRef(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      // Whether there is a play promise in progress which we should avoid interrupting\n      // with calls to video.play() or video.load()\n      isPlayAttemptInProgress: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: 0,\n    };\n  }\n\n  // Element refs\n  const containerRef = useRef(null);\n  const videoRef = useRef(null);\n\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n\n  // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled\n  const shouldPlayVideo = isHoveringOverVideo || focused;\n\n  /* ~~~~ EFFECTS ~~~~ */\n  // Effect starts and stops the video depending on the current value for `shouldPlayVideo`\n  useEffect(\n    () => {\n      const videoElement = videoRef.current;\n\n      // If shouldPlayVideo is true, attempt to start playing the video\n      if (shouldPlayVideo) {\n        // Use heuristics to check if the video is already playing.\n        if (\n          // A video is playing if...\n          // The video isn't paused\n          !videoElement.paused &&\n          // The video hasn't ended\n          !videoElement.ended &&\n          // The video has loaded enough data that it can play\n          // (readyState 3 is HAVE_FUTURE_DATA, meaning the video has loaded enough data that it can play)\n          videoElement.readyState >= 3\n        ) {\n          // If the video is already playing, ensure the overlays are hidden to reflect that!\n          setOverlayState(OverlayState.playing);\n        } else {\n          // If the video is not currently playing, proceed to kick off a loading timeout if needed and attempt to play the video\n          // if there isn't already one in progress\n\n          if (hasLoadingOverlay) {\n            // If we have a loading overlay, set a timeout to start showing it if the video doesn't start playing\n            // before the loading state timeout has elapsed\n            mutableVideoState.current.loadingStateTimeout = setTimeout(() => {\n              // If this timeout wasn't cancelled, we're still trying to play the video\n              // and it's still loading, so fade in the loading overlay\n              setOverlayState(OverlayState.loading);\n            }, loadingStateTimeout);\n          }\n\n          // If videoElement.paused is false that means a play attempt is already in progress so there's no need to actually\n          // start attempting to play again. This can happen if the video is taking a long time to load and still hasn't\n          // finished since the user has hovered off of the player and then back on again.\n          if (videoElement.paused) {\n            // Ensure we're at the correct time to start playing from\n            videoElement.currentTime =\n              mutableVideoState.current.videoTimeToRestore;\n\n            // Start attempting to play\n            videoElement.play();\n          }\n        }\n      }\n      // Otherwise if shouldPlayVideo is false, go through the process necessary to pause the video\n      else {\n        // Start fading the paused overlay back in\n        setOverlayState(OverlayState.paused);\n\n        // Only proceed to pause the video if it's not already paused\n        if (!videoElement.paused) {\n          const pauseVideo = () => {\n            // If there isn't a play attempt in progress and the video can therefore\n            //  safely be paused right away, do it!\n            // Otherwise, we'll have to wait for the logic in the video's `onPlaying` event\n            // to immediately pause the video as soon as it starts playing, or else we will end up\n            // getting an error for interrupting the play promise\n            if (!mutableVideoState.current.isPlayAttemptInProgress) {\n              videoElement.pause();\n            }\n          };\n\n          if (hasPausedOverlay) {\n            // If we have a paused overlay, set a timeout with a duration of the overlay's fade\n            // transition since we want to keep the video playing until the overlay has fully\n            // faded in and hidden it.\n            mutableVideoState.current.pauseTimeout = setTimeout(\n              pauseVideo,\n              overlayTransitionDuration\n            );\n          } else {\n            // If we don't have a paused overlay, pause right away!\n            pauseVideo();\n          }\n        }\n      }\n\n      return () => {\n        // On cleanup, clear any outstanding timeouts since our playback state is changing\n        // or the component is unmounting\n        clearTimeout(mutableVideoState.current.pauseTimeout);\n        clearTimeout(mutableVideoState.current.loadingStateTimeout);\n      };\n    },\n    // Only run the effect when shouldPlayVideo changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [shouldPlayVideo]\n  );\n\n  // If the video's sources should be unloaded when it's paused, the video is paused, AND we're not currently\n  // trying to play, we can unload the video's sources\n  const isVideoUnloaded =\n    unloadVideoOnPaused && isVideoPaused && !shouldPlayVideo;\n\n  // Effect ensures the video element fully unloads after its <source> tags were removed\n  useEffect(() => {\n    if (isVideoUnloaded) {\n      // Since the video's sources have changed, perform a manual load to update\n      // or unload the video's current source\n      videoRef.current.load();\n    }\n  }, [isVideoUnloaded]);\n\n  // Effect adds hover event listeners to the appropriate hover target element so it will start and stop as the user interacts with it\n  useEffect(() => {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined;\n\n    // If a ref to a custom hover target was provided, we'll use that as our target element,\n    // but otherwise just default to our container element\n    const hoverTargetElement = (hoverTargetRef || containerRef).current;\n\n    // Add the event listeners\n    const onHoverStart = () => setIsHoveringOverVideo(true);\n    const onHoverEnd = () => setIsHoveringOverVideo(false);\n\n    // Mouse events\n    hoverTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverTargetElement.addEventListener('mouseleave', onHoverEnd);\n\n    // Focus/blur\n    hoverTargetElement.addEventListener('focus', onHoverStart);\n    hoverTargetElement.addEventListener('blur', onHoverEnd);\n\n    // Touch events\n    hoverTargetElement.addEventListener('touchstart', onHoverStart);\n    // Event listener pauses the video when the user touches somewhere outside of the player\n    const onWindowTouchStart = (event: TouchEvent) => {\n      if (!hoverTargetElement.contains(event.target)) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener('touchstart', onWindowTouchStart);\n\n    // Return a cleanup function that removes all event listeners\n    return () => {\n      hoverTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverTargetElement.removeEventListener('focus', onHoverStart);\n      hoverTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetRef]);\n\n  // Effect sets attributes on the video which can't be done via props\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    videoElement.muted = muted;\n    // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n    videoElement.volume = volume;\n    // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n    // via the video element's props, so make sure we manually set them in an effect\n    videoElement.disableRemotePlayback = disableRemotePlayback;\n    videoElement.disablePictureInPicture = disablePictureInPicture;\n  }, [disablePictureInPicture, disableRemotePlayback, muted, volume]);\n  /* ~~~~ END EFFECTS ~~~~ */\n\n  const isPausedOverlayVisible = overlayState !== OverlayState.playing;\n  const isLoadingOverlayVisibile = overlayState === OverlayState.loading;\n\n  // Parse the sources and captions into formatted arrays that we can use to\n  // render <source> and <track> elements for the video\n  const formattedVideoSources = useMemo(() => formatVideoSrc(videoSrc), [\n    videoSrc,\n  ]);\n  const formattedVideoCaptions = useMemo(\n    () => formatVideoCaptions(videoCaptions),\n    [videoCaptions]\n  );\n\n  return (\n    <div\n      data-testid=\"hover-video-player-container\"\n      ref={containerRef}\n      className={className}\n      style={{\n        position: 'relative',\n        ...style,\n      }}\n    >\n      {hasPausedOverlay && (\n        <div\n          style={{\n            ...pausedOverlayWrapperSizingStyles[sizingMode],\n            zIndex: 1,\n            opacity: isPausedOverlayVisible ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the paused overlay when it's hidden\n            pointerEvents: isPausedOverlayVisible ? 'auto' : 'none',\n            ...pausedOverlayWrapperStyle,\n          }}\n          className={pausedOverlayWrapperClassName}\n          data-testid=\"paused-overlay-wrapper\"\n        >\n          {pausedOverlay}\n        </div>\n      )}\n      {hasLoadingOverlay && (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 2,\n            opacity: isLoadingOverlayVisibile ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the loading overlay when it's hidden\n            pointerEvents: isLoadingOverlayVisibile ? 'auto' : 'none',\n            ...loadingOverlayWrapperStyle,\n          }}\n          className={loadingOverlayWrapperClassName}\n          data-testid=\"loading-overlay-wrapper\"\n        >\n          {loadingOverlay}\n        </div>\n      )}\n      {/* eslint-disable-next-line jsx-a11y/media-has-caption */}\n      <video\n        loop={loop}\n        playsInline\n        preload={preload}\n        crossOrigin={crossOrigin}\n        ref={videoRef}\n        style={{\n          ...videoSizingStyles[sizingMode],\n          objectFit: 'cover',\n          ...videoStyle,\n        }}\n        controls={controls}\n        controlsList={controlsList}\n        className={videoClassName}\n        id={videoId}\n        onError={() => {\n          // Event fired when an error occurred on the video element, usually because something went wrong\n          // when attempting to load its source\n          console.error(\n            `HoverVideoPlayer encountered an error for src \"${videoRef.current.currentSrc}\".`\n          );\n        }}\n        onPlay={() => {\n          // Mark that we now have a play attempt in progress which shouldn't be interrupted\n          mutableVideoState.current.isPlayAttemptInProgress = true;\n          // The video is no longer paused\n          setIsVideoPaused(false);\n        }}\n        onPlaying={() => {\n          // Cancel any state timeouts that may be pending\n          clearTimeout(mutableVideoState.current.pauseTimeout);\n          clearTimeout(mutableVideoState.current.loadingStateTimeout);\n\n          // The play attempt is now complete\n          mutableVideoState.current.isPlayAttemptInProgress = false;\n\n          if (shouldPlayVideo) {\n            // Hide the overlays to reveal the video now that it's playing\n            setOverlayState(OverlayState.playing);\n          } else {\n            // If the play attempt just succeeded but we no longer want to play the video,\n            // pause it immediately!\n            videoRef.current.pause();\n          }\n        }}\n        onPause={() => {\n          // Cancel any state timeouts that may be pending\n          clearTimeout(mutableVideoState.current.pauseTimeout);\n          clearTimeout(mutableVideoState.current.loadingStateTimeout);\n\n          if (restartOnPaused) {\n            // If we should restart the video when paused, reset its time to the beginning\n            videoRef.current.currentTime = 0;\n          }\n\n          // Hang onto the time that the video is currently at so we can\n          // restore it when we try to play again\n          // This is mainly helpful because the unloadVideoOnPaused prop will cause\n          // the video's currentTime to be cleared every time its sources are unloaded\n          // after pausing\n          mutableVideoState.current.videoTimeToRestore =\n            videoRef.current.currentTime;\n\n          // Update that the video is now paused\n          setIsVideoPaused(true);\n        }}\n        data-testid=\"video-element\"\n      >\n        {!isVideoUnloaded &&\n          // Only render sources for the video if it is not unloaded\n          formattedVideoSources.map(({ src, type }) => (\n            <source key={src} src={src} type={type} />\n          ))}\n        {formattedVideoCaptions.map(\n          ({ src, srcLang, label, default: isDefault }) => (\n            <track\n              key={src}\n              kind=\"captions\"\n              src={src}\n              srcLang={srcLang}\n              label={label}\n              default={isDefault}\n            />\n          )\n        )}\n      </video>\n    </div>\n  );\n};\n\nexport default HoverVideoPlayer;\n"]},"metadata":{},"sourceType":"module"}