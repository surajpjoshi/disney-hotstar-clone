import React, { useState, useRef, useEffect, useMemo } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

// CSS styles to make some contents in the player expand to fill the container
var expandToFillContainerStyle = {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
};
// Styles to apply to the paused overlay wrapper for each sizing mode
var pausedOverlayWrapperSizingStyles = {
    // Sizing should be based on the video element, so make the overlay
    // expand to cover the player's container element
    video: expandToFillContainerStyle,
    // Sizing should be based on the paused overlay, so set position: relative
    // to make it occupy space in the document flow
    overlay: {
        position: 'relative',
    },
    // Sizing should be based on the player's container element, so make the overlay
    // expand to cover it
    container: expandToFillContainerStyle,
    // Don't apply any preset styling to the overlay
    manual: null,
};
// Styles to apply to the video element for each sizing mode
var videoSizingStyles = {
    // Sizing should be based on the video element, so set display: block
    // to make sure it occupies space in the document flow
    video: {
        display: 'block',
        // Ensure the video is sized relative to the container's width
        // rather than the video asset's native width
        width: '100%',
    },
    // Make the video element expand to cover the container if we're sizing
    // based on the overlay or container
    overlay: expandToFillContainerStyle,
    container: expandToFillContainerStyle,
    // Don't apply any preset styling to the video
    manual: null,
};

/**
 * @function  formatVideoSrc
 *
 * Takes a videoSrc value and formats it as an array of VideoSource objects which can be used to render
 * <source> elements for the video
 *
 * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.
 *
 * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video
 */
function formatVideoSrc(videoSrc) {
    var formattedVideoSources = [];
    if (videoSrc == null) {
        // A videoSrc value is required in order to make the video player work
        console.error("Error: 'videoSrc' prop is required for HoverVideoPlayer component");
    }
    else {
        // Make sure we can treat the videoSrc value as an array
        var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];
        // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video
        for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {
            var source = rawVideoSources[i];
            if (typeof source === 'string') {
                // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array
                formattedVideoSources.push({ src: source });
            }
            else if (source && source.src) {
                // If the source is an object with an src, just add it to the array
                formattedVideoSources.push({ src: source.src, type: source.type });
            }
            else {
                // Log an error if one of the videoSrc values is invalid
                console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':", source);
            }
        }
    }
    return formattedVideoSources;
}
/**
 * @function formatVideoCaptions
 *
 * Takes a videoCaptions value and formats it as an array of VideoCaptionsTrack objects which can be used to render
 * <track> elements for the video
 *
 * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.
 *
 * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video
 */
function formatVideoCaptions(videoCaptions) {
    var formattedVideoCaptions = [];
    // If captions were provided, format them for use for the video
    if (videoCaptions != null) {
        // Make sure we can treat the videoCaptions value as an array
        var rawVideoCaptions = Array.isArray(videoCaptions)
            ? videoCaptions
            : [videoCaptions];
        // Parse our raw video captions values into an array of formatted VideoCaptionsTrack
        // objects that can be used to render caption tracks for the video
        for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {
            var captions = rawVideoCaptions[i];
            if (captions && captions.src) {
                formattedVideoCaptions.push({
                    src: captions.src,
                    srcLang: captions.srcLang,
                    label: captions.label,
                    default: Boolean(captions.default),
                });
            }
            else {
                // Log an error if one of the videoCaptions values is invalid
                console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'", captions);
            }
        }
    }
    return formattedVideoCaptions;
}
// Enumerates states that the hover player's overlay can be in
var OverlayState;
(function (OverlayState) {
    // Only the paused overlay is visible, if provided
    OverlayState["paused"] = "paused";
    // Both the paused and loading overlays are visible, if provided
    OverlayState["loading"] = "loading";
    // No overlays are visible
    OverlayState["playing"] = "playing";
})(OverlayState || (OverlayState = {}));
/**
 * @component HoverVideoPlayer
 * @license MIT
 *
 * @param {HoverVideoPlayerProps} props
 */
var HoverVideoPlayer = function (_a) {
    var videoSrc = _a.videoSrc, _b = _a.videoCaptions, videoCaptions = _b === void 0 ? null : _b, _c = _a.focused, focused = _c === void 0 ? false : _c, _d = _a.disableDefaultEventHandling, disableDefaultEventHandling = _d === void 0 ? false : _d, _e = _a.hoverTargetRef, hoverTargetRef = _e === void 0 ? null : _e, _f = _a.pausedOverlay, pausedOverlay = _f === void 0 ? null : _f, _g = _a.loadingOverlay, loadingOverlay = _g === void 0 ? null : _g, _h = _a.loadingStateTimeout, loadingStateTimeout = _h === void 0 ? 200 : _h, _j = _a.overlayTransitionDuration, overlayTransitionDuration = _j === void 0 ? 400 : _j, _k = _a.restartOnPaused, restartOnPaused = _k === void 0 ? false : _k, _l = _a.unloadVideoOnPaused, unloadVideoOnPaused = _l === void 0 ? false : _l, _m = _a.muted, muted = _m === void 0 ? true : _m, _o = _a.volume, volume = _o === void 0 ? 1 : _o, _p = _a.loop, loop = _p === void 0 ? true : _p, _q = _a.preload, preload = _q === void 0 ? null : _q, _r = _a.crossOrigin, crossOrigin = _r === void 0 ? 'anonymous' : _r, _s = _a.controls, controls = _s === void 0 ? false : _s, _t = _a.controlsList, controlsList = _t === void 0 ? null : _t, _u = _a.disableRemotePlayback, disableRemotePlayback = _u === void 0 ? true : _u, _v = _a.disablePictureInPicture, disablePictureInPicture = _v === void 0 ? true : _v, _w = _a.className, className = _w === void 0 ? null : _w, _x = _a.style, style = _x === void 0 ? null : _x, _y = _a.pausedOverlayWrapperClassName, pausedOverlayWrapperClassName = _y === void 0 ? null : _y, _z = _a.pausedOverlayWrapperStyle, pausedOverlayWrapperStyle = _z === void 0 ? null : _z, _0 = _a.loadingOverlayWrapperClassName, loadingOverlayWrapperClassName = _0 === void 0 ? null : _0, _1 = _a.loadingOverlayWrapperStyle, loadingOverlayWrapperStyle = _1 === void 0 ? null : _1, _2 = _a.videoId, videoId = _2 === void 0 ? null : _2, _3 = _a.videoClassName, videoClassName = _3 === void 0 ? null : _3, _4 = _a.videoStyle, videoStyle = _4 === void 0 ? null : _4, _5 = _a.sizingMode, sizingMode = _5 === void 0 ? 'video' : _5;
    // Keep track of whether the user is hovering over the video and it should therefore be playing or not
    var _6 = useState(false), isHoveringOverVideo = _6[0], setIsHoveringOverVideo = _6[1];
    // Keep track of how the paused and loading overlays should be displayed
    var _7 = useState(OverlayState.paused), overlayState = _7[0], setOverlayState = _7[1];
    var _8 = useState(true), isVideoPaused = _8[0], setIsVideoPaused = _8[1];
    // Keep a ref for all state variables related to the video's state
    // which need to be managed asynchronously as it attempts to play/pause
    var mutableVideoState = useRef(null);
    if (mutableVideoState.current === null) {
        // Set initial values for our video state
        mutableVideoState.current = {
            // Whether there is a play promise in progress which we should avoid interrupting
            // with calls to video.play() or video.load()
            isPlayAttemptInProgress: false,
            // Keep refs for timeouts so we can keep track of and cancel them
            pauseTimeout: null,
            loadingStateTimeout: null,
            // Keep track of the video time that we should start from when the video is played again
            // This is particularly useful so we can restore our previous place in the video even if
            // we are unloading it every time it gets paused
            videoTimeToRestore: 0,
        };
    }
    // Element refs
    var containerRef = useRef(null);
    var videoRef = useRef(null);
    var hasPausedOverlay = Boolean(pausedOverlay);
    var hasLoadingOverlay = Boolean(loadingOverlay);
    // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled
    var shouldPlayVideo = isHoveringOverVideo || focused;
    /* ~~~~ EFFECTS ~~~~ */
    // Effect starts and stops the video depending on the current value for `shouldPlayVideo`
    useEffect(function () {
        var videoElement = videoRef.current;
        // If shouldPlayVideo is true, attempt to start playing the video
        if (shouldPlayVideo) {
            // Use heuristics to check if the video is already playing.
            if (
            // A video is playing if...
            // The video isn't paused
            !videoElement.paused &&
                // The video hasn't ended
                !videoElement.ended &&
                // The video has loaded enough data that it can play
                // (readyState 3 is HAVE_FUTURE_DATA, meaning the video has loaded enough data that it can play)
                videoElement.readyState >= 3) {
                // If the video is already playing, ensure the overlays are hidden to reflect that!
                setOverlayState(OverlayState.playing);
            }
            else {
                // If the video is not currently playing, proceed to kick off a loading timeout if needed and attempt to play the video
                // if there isn't already one in progress
                if (hasLoadingOverlay) {
                    // If we have a loading overlay, set a timeout to start showing it if the video doesn't start playing
                    // before the loading state timeout has elapsed
                    mutableVideoState.current.loadingStateTimeout = setTimeout(function () {
                        // If this timeout wasn't cancelled, we're still trying to play the video
                        // and it's still loading, so fade in the loading overlay
                        setOverlayState(OverlayState.loading);
                    }, loadingStateTimeout);
                }
                // If videoElement.paused is false that means a play attempt is already in progress so there's no need to actually
                // start attempting to play again. This can happen if the video is taking a long time to load and still hasn't
                // finished since the user has hovered off of the player and then back on again.
                if (videoElement.paused) {
                    // Ensure we're at the correct time to start playing from
                    videoElement.currentTime =
                        mutableVideoState.current.videoTimeToRestore;
                    // Start attempting to play
                    videoElement.play();
                }
            }
        }
        // Otherwise if shouldPlayVideo is false, go through the process necessary to pause the video
        else {
            // Start fading the paused overlay back in
            setOverlayState(OverlayState.paused);
            // Only proceed to pause the video if it's not already paused
            if (!videoElement.paused) {
                var pauseVideo = function () {
                    // If there isn't a play attempt in progress and the video can therefore
                    //  safely be paused right away, do it!
                    // Otherwise, we'll have to wait for the logic in the video's `onPlaying` event
                    // to immediately pause the video as soon as it starts playing, or else we will end up
                    // getting an error for interrupting the play promise
                    if (!mutableVideoState.current.isPlayAttemptInProgress) {
                        videoElement.pause();
                    }
                };
                if (hasPausedOverlay) {
                    // If we have a paused overlay, set a timeout with a duration of the overlay's fade
                    // transition since we want to keep the video playing until the overlay has fully
                    // faded in and hidden it.
                    mutableVideoState.current.pauseTimeout = setTimeout(pauseVideo, overlayTransitionDuration);
                }
                else {
                    // If we don't have a paused overlay, pause right away!
                    pauseVideo();
                }
            }
        }
        return function () {
            // On cleanup, clear any outstanding timeouts since our playback state is changing
            // or the component is unmounting
            clearTimeout(mutableVideoState.current.pauseTimeout);
            clearTimeout(mutableVideoState.current.loadingStateTimeout);
        };
    }, 
    // Only run the effect when shouldPlayVideo changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [shouldPlayVideo]);
    // If the video's sources should be unloaded when it's paused, the video is paused, AND we're not currently
    // trying to play, we can unload the video's sources
    var isVideoUnloaded = unloadVideoOnPaused && isVideoPaused && !shouldPlayVideo;
    // Effect ensures the video element fully unloads after its <source> tags were removed
    useEffect(function () {
        if (isVideoUnloaded) {
            // Since the video's sources have changed, perform a manual load to update
            // or unload the video's current source
            videoRef.current.load();
        }
    }, [isVideoUnloaded]);
    // Effect adds hover event listeners to the appropriate hover target element so it will start and stop as the user interacts with it
    useEffect(function () {
        // If default event handling is disabled, we shouldn't check for touch events outside of the player
        if (disableDefaultEventHandling)
            return undefined;
        // If a ref to a custom hover target was provided, we'll use that as our target element,
        // but otherwise just default to our container element
        var hoverTargetElement = (hoverTargetRef || containerRef).current;
        // Add the event listeners
        var onHoverStart = function () { return setIsHoveringOverVideo(true); };
        var onHoverEnd = function () { return setIsHoveringOverVideo(false); };
        // Mouse events
        hoverTargetElement.addEventListener('mouseenter', onHoverStart);
        hoverTargetElement.addEventListener('mouseleave', onHoverEnd);
        // Focus/blur
        hoverTargetElement.addEventListener('focus', onHoverStart);
        hoverTargetElement.addEventListener('blur', onHoverEnd);
        // Touch events
        hoverTargetElement.addEventListener('touchstart', onHoverStart);
        // Event listener pauses the video when the user touches somewhere outside of the player
        var onWindowTouchStart = function (event) {
            if (!hoverTargetElement.contains(event.target)) {
                onHoverEnd();
            }
        };
        window.addEventListener('touchstart', onWindowTouchStart);
        // Return a cleanup function that removes all event listeners
        return function () {
            hoverTargetElement.removeEventListener('mouseenter', onHoverStart);
            hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);
            hoverTargetElement.removeEventListener('focus', onHoverStart);
            hoverTargetElement.removeEventListener('blur', onHoverEnd);
            hoverTargetElement.removeEventListener('touchstart', onHoverStart);
            window.removeEventListener('touchstart', onWindowTouchStart);
        };
    }, [disableDefaultEventHandling, hoverTargetRef]);
    // Effect sets attributes on the video which can't be done via props
    useEffect(function () {
        var videoElement = videoRef.current;
        // Manually setting the `muted` attribute on the video element via an effect in order
        // to avoid a know React issue with the `muted` prop not applying correctly on initial render
        // https://github.com/facebook/react/issues/10389
        videoElement.muted = muted;
        // Set the video's volume to match the `volume` prop
        // Note that this will have no effect if the `muted` prop is set to true
        videoElement.volume = volume;
        // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly
        // via the video element's props, so make sure we manually set them in an effect
        videoElement.disableRemotePlayback = disableRemotePlayback;
        videoElement.disablePictureInPicture = disablePictureInPicture;
    }, [disablePictureInPicture, disableRemotePlayback, muted, volume]);
    /* ~~~~ END EFFECTS ~~~~ */
    var isPausedOverlayVisible = overlayState !== OverlayState.playing;
    var isLoadingOverlayVisibile = overlayState === OverlayState.loading;
    // Parse the sources and captions into formatted arrays that we can use to
    // render <source> and <track> elements for the video
    var formattedVideoSources = useMemo(function () { return formatVideoSrc(videoSrc); }, [
        videoSrc,
    ]);
    var formattedVideoCaptions = useMemo(function () { return formatVideoCaptions(videoCaptions); }, [videoCaptions]);
    return (React.createElement("div", { "data-testid": "hover-video-player-container", ref: containerRef, className: className, style: __assign({ position: 'relative' }, style) },
        hasPausedOverlay && (React.createElement("div", { style: __assign(__assign(__assign({}, pausedOverlayWrapperSizingStyles[sizingMode]), { zIndex: 1, opacity: isPausedOverlayVisible ? 1 : 0, transition: "opacity " + overlayTransitionDuration + "ms", 
                // Disable pointer events on the paused overlay when it's hidden
                pointerEvents: isPausedOverlayVisible ? 'auto' : 'none' }), pausedOverlayWrapperStyle), className: pausedOverlayWrapperClassName, "data-testid": "paused-overlay-wrapper" }, pausedOverlay)),
        hasLoadingOverlay && (React.createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), { zIndex: 2, opacity: isLoadingOverlayVisibile ? 1 : 0, transition: "opacity " + overlayTransitionDuration + "ms", 
                // Disable pointer events on the loading overlay when it's hidden
                pointerEvents: isLoadingOverlayVisibile ? 'auto' : 'none' }), loadingOverlayWrapperStyle), className: loadingOverlayWrapperClassName, "data-testid": "loading-overlay-wrapper" }, loadingOverlay)),
        React.createElement("video", { loop: loop, playsInline: true, preload: preload, crossOrigin: crossOrigin, ref: videoRef, style: __assign(__assign(__assign({}, videoSizingStyles[sizingMode]), { objectFit: 'cover' }), videoStyle), controls: controls, controlsList: controlsList, className: videoClassName, id: videoId, onError: function () {
                // Event fired when an error occurred on the video element, usually because something went wrong
                // when attempting to load its source
                console.error("HoverVideoPlayer encountered an error for src \"" + videoRef.current.currentSrc + "\".");
            }, onPlay: function () {
                // Mark that we now have a play attempt in progress which shouldn't be interrupted
                mutableVideoState.current.isPlayAttemptInProgress = true;
                // The video is no longer paused
                setIsVideoPaused(false);
            }, onPlaying: function () {
                // Cancel any state timeouts that may be pending
                clearTimeout(mutableVideoState.current.pauseTimeout);
                clearTimeout(mutableVideoState.current.loadingStateTimeout);
                // The play attempt is now complete
                mutableVideoState.current.isPlayAttemptInProgress = false;
                if (shouldPlayVideo) {
                    // Hide the overlays to reveal the video now that it's playing
                    setOverlayState(OverlayState.playing);
                }
                else {
                    // If the play attempt just succeeded but we no longer want to play the video,
                    // pause it immediately!
                    videoRef.current.pause();
                }
            }, onPause: function () {
                // Cancel any state timeouts that may be pending
                clearTimeout(mutableVideoState.current.pauseTimeout);
                clearTimeout(mutableVideoState.current.loadingStateTimeout);
                if (restartOnPaused) {
                    // If we should restart the video when paused, reset its time to the beginning
                    videoRef.current.currentTime = 0;
                }
                // Hang onto the time that the video is currently at so we can
                // restore it when we try to play again
                // This is mainly helpful because the unloadVideoOnPaused prop will cause
                // the video's currentTime to be cleared every time its sources are unloaded
                // after pausing
                mutableVideoState.current.videoTimeToRestore =
                    videoRef.current.currentTime;
                // Update that the video is now paused
                setIsVideoPaused(true);
            }, "data-testid": "video-element" },
            !isVideoUnloaded &&
                // Only render sources for the video if it is not unloaded
                formattedVideoSources.map(function (_a) {
                    var src = _a.src, type = _a.type;
                    return (React.createElement("source", { key: src, src: src, type: type }));
                }),
            formattedVideoCaptions.map(function (_a) {
                var src = _a.src, srcLang = _a.srcLang, label = _a.label, isDefault = _a.default;
                return (React.createElement("track", { key: src, kind: "captions", src: src, srcLang: srcLang, label: label, default: isDefault }));
            }))));
};

export default HoverVideoPlayer;
//# sourceMappingURL=index.esm.js.map
